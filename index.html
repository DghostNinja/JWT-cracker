<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JWT Cracker & Editor</title>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto Mono', monospace;
      background: #f5f7fa;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    h1, h2 {
      color: #2c3e50;
    }
    textarea, input[type="text"], input[type="file"] {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 14px;
    }
    button {
      background: #2980b9;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
    }
    button:hover {
      background: #3498db;
    }
    .section {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    #result, #encodedResult {
      margin-top: 10px;
      font-weight: bold;
    }
    .success {
      color: green;
    }
    .error {
      color: red;
    }
    #progressContainer {
      display: none;
      margin-top: 10px;
    }
    progress {
      width: 100%;
      height: 20px;
    }
  </style>
</head>
<body>
  <h1>JWT Secret Key Cracker & Editor</h1>

  <div class="section">
    <h2>Crack JWT Secret</h2>
    <label for="jwtInput">Paste JWT:</label>
    <textarea id="jwtInput" rows="4" oninput="autoDecodeJWT()"></textarea>

    <label for="wordlistInput">Upload Wordlist (.txt):</label>
    <input type="file" id="wordlistInput" accept=".txt">

    <button onclick="crackJWT()">Crack JWT</button>

    <div id="progressContainer">
      <progress id="progressBar" value="0" max="100"></progress>
      <div id="progressPercent">0%</div>
    </div>

    <p id="result"></p>
  </div>

  <div class="section">
    <h2>Decode & Edit JWT</h2>
    <label for="decodedHeader">Header (JSON):</label>
    <textarea id="decodedHeader" rows="5" oninput="updateJWTFromEdits()"></textarea>

    <label for="decodedPayload">Payload (JSON):</label>
    <textarea id="decodedPayload" rows="10" oninput="updateJWTFromEdits()"></textarea>

    <label for="editSecret">Optional Secret Key (to sign):</label>
    <input type="text" id="editSecret" oninput="updateJWTFromEdits()">

    <p id="encodedResult"></p>
  </div>

  <script>
    function base64UrlDecode(input) {
      input = input.replace(/-/g, '+').replace(/_/g, '/');
      const pad = input.length % 4;
      if (pad) input += '='.repeat(4 - pad);
      return atob(input);
    }

    function base64UrlEncode(input) {
      return btoa(input).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    function autoDecodeJWT() {
      const jwtInput = document.getElementById('jwtInput').value.trim();
      const parts = jwtInput.split('.');
      if (parts.length !== 3) return;

      try {
        const header = JSON.parse(base64UrlDecode(parts[0]));
        const payload = JSON.parse(base64UrlDecode(parts[1]));

        document.getElementById('decodedHeader').value = JSON.stringify(header, null, 2);
        document.getElementById('decodedPayload').value = JSON.stringify(payload, null, 2);
      } catch (e) {
        console.warn('Failed to decode:', e.message);
      }
    }

    function readWordlist(file, callback) {
      const reader = new FileReader();
      reader.onload = () => {
        const words = reader.result.split(/\r?\n/).filter(w => w.trim() !== '');
        callback(words);
      };
      reader.readAsText(file);
    }

    function crackJWT() {
      const jwt = document.getElementById('jwtInput').value.trim();
      const wordlistFile = document.getElementById('wordlistInput').files[0];
      const resultDisplay = document.getElementById('result');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressPercent');
      const progressContainer = document.getElementById('progressContainer');

      resultDisplay.className = '';
      resultDisplay.textContent = '';
      progressBar.value = 0;
      progressText.textContent = '0%';
      progressContainer.style.display = 'block';

      if (!jwt || !wordlistFile) {
        resultDisplay.textContent = 'Please input JWT and upload a wordlist.';
        resultDisplay.className = 'error';
        progressContainer.style.display = 'none';
        return;
      }

      const parts = jwt.split('.');
      if (parts.length !== 3) {
        resultDisplay.textContent = 'Invalid JWT format.';
        resultDisplay.className = 'error';
        progressContainer.style.display = 'none';
        return;
      }

      try {
        const headerJson = JSON.parse(base64UrlDecode(parts[0]));
        if (headerJson.alg !== 'HS256') {
          resultDisplay.textContent = `Unsupported algorithm (${headerJson.alg}). Only HS256 is supported.`;
          resultDisplay.className = 'error';
          progressContainer.style.display = 'none';
          return;
        }
      } catch (e) {
        resultDisplay.textContent = 'Invalid JWT header.';
        resultDisplay.className = 'error';
        progressContainer.style.display = 'none';
        return;
      }

      const data = `${parts[0]}.${parts[1]}`;
      const signature = parts[2];

      readWordlist(wordlistFile, wordlist => {
        let found = false;
        const total = wordlist.length;

        function tryNext(index) {
          if (index >= total) {
            resultDisplay.textContent = 'Secret not found in wordlist.';
            resultDisplay.className = 'error';
            progressContainer.style.display = 'none';
            return;
          }

          const secret = wordlist[index];
          const hmac = CryptoJS.HmacSHA256(data, secret);
          const hash = CryptoJS.enc.Base64url.stringify(hmac);
          const percent = Math.floor(((index + 1) / total) * 100);

          progressBar.value = percent;
          progressText.textContent = `${percent}%`;

          if (hash === signature) {
            resultDisplay.textContent = `Secret found: ${secret}`;
            resultDisplay.className = 'success';
            progressContainer.style.display = 'none';
            return;
          }

          // Non-blocking loop
          setTimeout(() => tryNext(index + 1), 5);
        }

        tryNext(0);
      });
    }

    function updateJWTFromEdits() {
      const headerJSON = document.getElementById('decodedHeader').value.trim();
      const payloadJSON = document.getElementById('decodedPayload').value.trim();
      const secret = document.getElementById('editSecret').value.trim();
      const jwtInput = document.getElementById('jwtInput');
      const output = document.getElementById('encodedResult');

      try {
        const header = JSON.parse(headerJSON);
        const payload = JSON.parse(payloadJSON);

        const encodedHeader = base64UrlEncode(JSON.stringify(header));
        const encodedPayload = base64UrlEncode(JSON.stringify(payload));
        const data = `${encodedHeader}.${encodedPayload}`;
        let fullJWT = data;

        if (secret) {
          const hmac = CryptoJS.HmacSHA256(data, secret);
          const signature = CryptoJS.enc.Base64url.stringify(hmac);
          fullJWT += `.${signature}`;
        }

        jwtInput.value = fullJWT;
        output.textContent = fullJWT;
      } catch (e) {
        output.textContent = 'Invalid JSON format';
      }
    }
  </script>
</body>
</html>
